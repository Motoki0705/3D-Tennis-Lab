model:
  vit_name: tiny # tiny|small etc. (timm name or alias)
  pretrained: true
  decoder: simple # simple pixel-avg upsampler; optional future: pixel_shuffle
  deep_supervision_strides: [8, 4] # output strides relative to input image size
  heatmap_channels: 1
  offset_channels: 2
  coord_mode: argmax # softargmax|argmax
  softargmax_temp: 2.0

dataset:
  img_dir: data/processed/ball/images
  annotation_file: data/processed/ball/annotation.json
  img_size: [512, 512]
  heatmap:
    strides: [8, 4] # must align with model.deep_supervision_strides
    sigmas: [2.5, 2.0] # per-scale gaussian sigma in heatmap pixels
    offset_mask_tau: 0.3 # offsets supervised where heatmap > tau
  negatives: use # none|use|skip
  version_field: view # key in image meta or parsable from path; expected values {v1,v2}
  version_weights: { v1: 0.7, v2: 0.3 }
  v_mix_schedule: # optional; if set, overrides version_weights epoch-wise
    - { epoch_le: 5, v1: 0.5, v2: 0.5 }
    - { epoch_le: 20, v1: 0.8, v2: 0.2 }
  loader:
    batch_size: 16
    num_workers: 4
    sampler: weighted # weighted|balanced|uniform
    pin_memory: true
    persistent_workers: false
  split:
    train_ratio: 0.8
    val_ratio: 0.1

training:
  max_epochs: 30
  precision: 16-mixed
  accelerator: gpu
  devices: 1
  lr_head: 3e-4
  vit_lr: 1e-5
  weight_decay: 0.0001
  freeze_vit_epochs: 5
  loss:
    lambda_hmap: 1.0
    lambda_offset: 1.0
    lambda_coord: 0.0
    deep_supervision_weights: [0.4, 0.6]
    focal: false
    pos_weight: 25.0 # for weighted MSE heatmap loss (pos:neg)
    pos_mask_tau: 0.3 # threshold to define positive region in Gaussian target

evaluation:
  pck_thresholds: [0.02, 0.03, 0.05]

callbacks:
  checkpoint: best_val
  early_stopping: val/total_loss
  heatmap_logger:
    _target_: HeatmapLoggerV2
    num_samples: 8
    draw_offset: true
    draw_coord: true
    draw_multiscale: true
    log_interval_epochs: 1
